{"remainingRequest":"/Users/leeco/Documents/vue-sell-cube/node_modules/babel-loader/lib/index.js!/Users/leeco/Documents/vue-sell-cube/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/leeco/Documents/vue-sell-cube/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/leeco/Documents/vue-sell-cube/node_modules/cube-ui/src/components/recycle-list/recycle-list.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cube-ui/src/components/recycle-list/recycle-list.vue","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport CubeLoading from '../loading/loading.vue';\nimport { warn } from '../../common/helpers/debug.js';\nimport { isUndef } from '../../common/helpers/util.js';\nvar COMPONENT_NAME = 'cube-recycle-list';\nvar PROMISE_ERROR = 'requires a Promise polyfill in this browser.';\nvar EVENT_SCROLL = 'scroll';\nvar EVENT_RESIZE = 'resize';\nexport default {\n  name: COMPONENT_NAME,\n  data: function data() {\n    return {\n      items: [],\n      heights: 0,\n      startIndex: 0,\n      loadings: [],\n      noMore: false\n    };\n  },\n  props: {\n    infinite: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      type: Number,\n      default: 20\n    },\n    offset: {\n      type: Number,\n      default: 100\n    },\n    onFetch: {\n      type: Function,\n      required: true\n    }\n  },\n  computed: {\n    visibleItems: function visibleItems() {\n      return this.items.slice(Math.max(0, this.startIndex - this.size), Math.min(this.items.length, this.startIndex + this.size));\n    },\n    tombHeight: function tombHeight() {\n      return this.infinite ? this.$refs.tomb && this.$refs.tomb.offsetHeight : 0;\n    },\n    loading: function loading() {\n      return this.loadings.length;\n    }\n  },\n  created: function created() {\n    this.list = [];\n    this.promiseStack = [];\n  },\n  mounted: function mounted() {\n    this.checkPromiseCompatibility();\n    this.$el.addEventListener(EVENT_SCROLL, this._onScroll);\n    window.addEventListener(EVENT_RESIZE, this._onResize);\n    this.load();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.$el.removeEventListener(EVENT_SCROLL, this._onScroll);\n    window.removeEventListener(EVENT_RESIZE, this._onResize);\n  },\n  methods: {\n    checkPromiseCompatibility: function checkPromiseCompatibility() {\n      /* istanbul ignore if */\n      if (isUndef(window.Promise)) {\n        warn(PROMISE_ERROR);\n      }\n    },\n    load: function load() {\n      if (this.infinite) {\n        var items = this.items;\n        var start = items.length; // increase capacity of items to display tombstone\n\n        items.length += this.size;\n        var end = items.length;\n        this.loadItems(start, end);\n        this.getItems();\n      } else if (!this.loading) {\n        this.getItems();\n      }\n    },\n    getItems: function getItems() {\n      var _this = this;\n\n      var index = this.promiseStack.length;\n      var promiseFetch = this.onFetch();\n      this.loadings.push('pending');\n      this.promiseStack.push(promiseFetch);\n      promiseFetch.then(function (res) {\n        _this.loadings.pop();\n        /* istanbul ignore if */\n\n\n        if (!res) {\n          _this.stopScroll(index);\n        } else {\n          _this.setList(index, res);\n\n          _this.loadItemsByIndex(index);\n\n          if (res.length < _this.size) {\n            _this.stopScroll(index);\n          }\n        }\n      });\n    },\n    removeUnusedTombs: function removeUnusedTombs(copy, index) {\n      var cursor;\n      var size = this.size;\n      var start = index * size;\n      var end = (index + 1) * size;\n\n      for (cursor = start; cursor < end; cursor++) {\n        if (copy[cursor] && copy[cursor].isTombstone) break;\n      }\n\n      this.items = copy.slice(0, cursor);\n    },\n    stopScroll: function stopScroll(index) {\n      this.noMore = true;\n      this.removeUnusedTombs(this.items.slice(0), index);\n      this.updateItemTop();\n      this.updateStartIndex();\n    },\n    setList: function setList(index, res) {\n      var list = this.list;\n      var baseIndex = index * this.size;\n\n      for (var i = 0; i < res.length; i++) {\n        list[baseIndex + i] = res[i];\n      }\n    },\n    loadItemsByIndex: function loadItemsByIndex(index) {\n      var size = this.size;\n      var start = index * size;\n      var end = (index + 1) * size;\n      this.loadItems(start, end);\n    },\n    loadItems: function loadItems(start, end) {\n      var _this2 = this;\n\n      var items = this.items;\n      var promiseTasks = [];\n      var item;\n\n      var _loop = function _loop(i) {\n        item = items[i];\n        /* istanbul ignore if */\n\n        if (item && item.loaded) {\n          return \"continue\";\n        }\n\n        _this2.setItem(i, _this2.list[i]); // get each item's height in nextTick\n\n\n        promiseTasks.push(_this2.$nextTick().then(function () {\n          _this2.updateItemHeight(i);\n        }));\n      };\n\n      for (var i = start; i < end; i++) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      } // update items top and full list height\n\n\n      window.Promise.all(promiseTasks).then(function () {\n        _this2.updateItemTop();\n\n        _this2.updateStartIndex();\n      });\n    },\n    setItem: function setItem(index, data) {\n      this.$set(this.items, index, {\n        data: data || {},\n        height: 0,\n        top: -1000,\n        isTombstone: !data,\n        loaded: data ? 1 : 0\n      });\n    },\n    updateItemHeight: function updateItemHeight(index) {\n      // update item height\n      var cur = this.items[index];\n      var dom = this.$refs['preloads' + index];\n\n      if (dom && dom[0]) {\n        cur.height = dom[0].offsetHeight;\n      } else if (cur) {\n        cur.height = this.tombHeight;\n      }\n    },\n    updateItemTop: function updateItemTop() {\n      var heights = 0;\n      var items = this.items;\n      var pre;\n      var current; // loop all items to update item top and list height\n\n      for (var i = 0; i < items.length; i++) {\n        pre = items[i - 1];\n        current = items[i]; // it is empty in array\n\n        /* istanbul ignore if */\n\n        if (!items[i]) {\n          heights += 0;\n        } else {\n          current.top = pre ? pre.top + pre.height : 0;\n          heights += current.height;\n        }\n      }\n\n      this.heights = heights;\n    },\n    updateStartIndex: function updateStartIndex() {\n      // update visible items start index\n      var top = this.$el.scrollTop;\n      var item;\n      var items = this.items;\n\n      for (var i = 0; i < items.length; i++) {\n        item = items[i];\n\n        if (!item || item.top > top) {\n          this.startIndex = Math.max(0, i - 1);\n          break;\n        }\n      }\n    },\n    reset: function reset() {\n      var _this3 = this;\n\n      var map = [{\n        key: 'items',\n        value: []\n      }, {\n        key: 'heights',\n        value: 0\n      }, {\n        key: 'startIndex',\n        value: 0\n      }, {\n        key: 'loadings',\n        value: []\n      }, {\n        key: 'noMore',\n        value: false\n      }, {\n        key: 'list',\n        value: []\n      }, {\n        key: 'promiseStack',\n        value: []\n      }];\n      map.forEach(function (_ref) {\n        var key = _ref.key,\n            value = _ref.value;\n        _this3[key] = value;\n      });\n      this.$el.scrollTop = 0;\n      this.load();\n    },\n    _onScroll: function _onScroll() {\n      // trigger load\n      if (!this.noMore && this.$el.scrollTop + this.$el.offsetHeight > this.heights - this.offset) {\n        this.load();\n      }\n\n      this.updateStartIndex();\n    },\n    _onResize: function _onResize() {\n      var items = this.items;\n      items.forEach(function (item) {\n        item.loaded = false;\n      });\n      this.loadItems(0, items.length);\n    }\n  },\n  components: {\n    CubeLoading: CubeLoading\n  }\n};",{"version":3,"sources":["recycle-list.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"cube-recycle-list\">\n    <div class=\"cube-recycle-list-main\">\n      <div class=\"cube-recycle-list-items\" :style=\"{height: heights + 'px'}\">\n        <div\n          v-for=\"item in visibleItems\"\n          class=\"cube-recycle-list-item\"\n          :style=\"{transform: 'translate(0,' + item.top + 'px)'}\"\n        >\n          <div\n            v-if=\"infinite\"\n            :class=\"{'cube-recycle-list-transition': infinite}\"\n            :style=\"{opacity: +!item.loaded}\"\n          >\n            <slot name=\"tombstone\"></slot>\n          </div>\n          <div\n            :class=\"{'cube-recycle-list-transition': infinite}\"\n            :style=\"{opacity: item.loaded}\"\n          >\n            <slot name=\"item\" :data=\"item.data\"></slot>\n          </div>\n        </div>\n\n        <!-- preloads item for get its height, remove it after caculating height-->\n        <div class=\"cube-recycle-list-pool\">\n          <div\n            class=\"cube-recycle-list-item cube-recycle-list-invisible\"\n            v-if=\"item && !item.isTombstone && !item.height\"\n            :ref=\"'preloads'+index\"\n            v-for=\"(item, index) in items\"\n          >\n            <slot name=\"item\" :data=\"item.data\"></slot>\n          </div>\n          <div ref=\"tomb\" class=\"cube-recycle-list-item cube-recycle-list-invisible\">\n            <slot name=\"tombstone\"></slot>\n          </div>\n        </div>\n      </div>\n      <div\n        v-if=\"!infinite && !noMore\"\n        class=\"cube-recycle-list-loading\"\n        :style=\"{visibility: loading ? 'visible' : 'hidden'}\"\n      >\n        <slot name=\"spinner\">\n          <div class=\"cube-recycle-list-loading-content\">\n            <cube-loading class=\"cube-recycle-list-spinner\"></cube-loading>\n          </div>\n        </slot>\n      </div>\n\n      <div v-show=\"noMore\" class=\"cube-recycle-list-noMore\">\n        <slot name=\"noMore\" />\n      </div>\n    </div>\n    <div class=\"cube-recycle-list-fake\"></div>\n  </div>\n</template>\n\n<script>\n  import CubeLoading from '../loading/loading.vue'\n  import { warn } from '../../common/helpers/debug.js'\n  import { isUndef } from '../../common/helpers/util.js'\n\n  const COMPONENT_NAME = 'cube-recycle-list'\n  const PROMISE_ERROR = 'requires a Promise polyfill in this browser.'\n  const EVENT_SCROLL = 'scroll'\n  const EVENT_RESIZE = 'resize'\n\n  export default {\n    name: COMPONENT_NAME,\n    data() {\n      return {\n        items: [],\n        heights: 0,\n        startIndex: 0,\n        loadings: [],\n        noMore: false\n      }\n    },\n    props: {\n      infinite: {\n        type: Boolean,\n        default: false\n      },\n      size: {\n        type: Number,\n        default: 20\n      },\n      offset: {\n        type: Number,\n        default: 100\n      },\n      onFetch: {\n        type: Function,\n        required: true\n      }\n    },\n    computed: {\n      visibleItems() {\n        return this.items.slice(Math.max(0, this.startIndex - this.size), Math.min(this.items.length, this.startIndex + this.size))\n      },\n      tombHeight() {\n        return this.infinite ? this.$refs.tomb && this.$refs.tomb.offsetHeight : 0\n      },\n      loading() {\n        return this.loadings.length\n      }\n    },\n    created() {\n      this.list = []\n      this.promiseStack = []\n    },\n    mounted() {\n      this.checkPromiseCompatibility()\n      this.$el.addEventListener(EVENT_SCROLL, this._onScroll)\n      window.addEventListener(EVENT_RESIZE, this._onResize)\n      this.load()\n    },\n    beforeDestroy() {\n      this.$el.removeEventListener(EVENT_SCROLL, this._onScroll)\n      window.removeEventListener(EVENT_RESIZE, this._onResize)\n    },\n    methods: {\n      checkPromiseCompatibility() {\n        /* istanbul ignore if */\n        if (isUndef(window.Promise)) {\n          warn(PROMISE_ERROR)\n        }\n      },\n      load() {\n        if (this.infinite) {\n          const items = this.items\n          const start = items.length\n          // increase capacity of items to display tombstone\n          items.length += this.size\n          const end = items.length\n          this.loadItems(start, end)\n          this.getItems()\n        } else if (!this.loading) {\n          this.getItems()\n        }\n      },\n      getItems() {\n        const index = this.promiseStack.length\n        const promiseFetch = this.onFetch()\n        this.loadings.push('pending')\n        this.promiseStack.push(promiseFetch)\n        promiseFetch.then((res) => {\n          this.loadings.pop()\n          /* istanbul ignore if */\n          if (!res) {\n            this.stopScroll(index)\n          } else {\n            this.setList(index, res)\n            this.loadItemsByIndex(index)\n            if (res.length < this.size) {\n              this.stopScroll(index)\n            }\n          }\n        })\n      },\n      removeUnusedTombs(copy, index) {\n        let cursor\n        let size = this.size\n        let start = index * size\n        let end = (index + 1) * size\n        for (cursor = start; cursor < end; cursor++) {\n          if (copy[cursor] && copy[cursor].isTombstone) break\n        }\n        this.items = copy.slice(0, cursor)\n      },\n      stopScroll(index) {\n        this.noMore = true\n        this.removeUnusedTombs(this.items.slice(0), index)\n        this.updateItemTop()\n        this.updateStartIndex()\n      },\n      setList(index, res) {\n        const list = this.list\n        const baseIndex = index * this.size\n        for (let i = 0; i < res.length; i++) {\n          list[baseIndex + i] = res[i]\n        }\n      },\n      loadItemsByIndex(index) {\n        const size = this.size\n        const start = index * size\n        const end = (index + 1) * size\n        this.loadItems(start, end)\n      },\n      loadItems(start, end) {\n        const items = this.items\n        let promiseTasks = []\n        let item\n        for (let i = start; i < end; i++) {\n          item = items[i]\n          /* istanbul ignore if */\n          if (item && item.loaded) {\n            continue\n          }\n          this.setItem(i, this.list[i])\n          // get each item's height in nextTick\n          promiseTasks.push(this.$nextTick().then(() => {\n            this.updateItemHeight(i)\n          }))\n        }\n        // update items top and full list height\n        window.Promise.all(promiseTasks).then(() => {\n          this.updateItemTop()\n          this.updateStartIndex()\n        })\n      },\n      setItem(index, data) {\n        this.$set(this.items, index, {\n          data: data || {},\n          height: 0,\n          top: -1000,\n          isTombstone: !data,\n          loaded: data ? 1 : 0\n        })\n      },\n      updateItemHeight(index) {\n        // update item height\n        let cur = this.items[index]\n        let dom = this.$refs['preloads' + index]\n        if (dom && dom[0]) {\n          cur.height = dom[0].offsetHeight\n        } else if (cur) {\n          cur.height = this.tombHeight\n        }\n      },\n      updateItemTop() {\n        let heights = 0\n        const items = this.items\n        let pre\n        let current\n        // loop all items to update item top and list height\n        for (let i = 0; i < items.length; i++) {\n          pre = items[i - 1]\n          current = items[i]\n          // it is empty in array\n          /* istanbul ignore if */\n          if (!items[i]) {\n            heights += 0\n          } else {\n            current.top = pre ? pre.top + pre.height : 0\n            heights += current.height\n          }\n        }\n        this.heights = heights\n      },\n      updateStartIndex() {\n        // update visible items start index\n        let top = this.$el.scrollTop\n        let item\n        const items = this.items\n        for (let i = 0; i < items.length; i++) {\n          item = items[i]\n          if (!item || item.top > top) {\n            this.startIndex = Math.max(0, i - 1)\n            break\n          }\n        }\n      },\n      reset () {\n        const map = [\n          {\n            key: 'items',\n            value: []\n          },\n          {\n            key: 'heights',\n            value: 0\n          },\n          {\n            key: 'startIndex',\n            value: 0\n          },\n          {\n            key: 'loadings',\n            value: []\n          },\n          {\n            key: 'noMore',\n            value: false\n          },\n          {\n            key: 'list',\n            value: []\n          },\n          {\n            key: 'promiseStack',\n            value: []\n          }\n        ]\n        map.forEach(({ key, value }) => {\n          this[key] = value\n        })\n        this.$el.scrollTop = 0\n        this.load()\n      },\n      _onScroll() {\n        // trigger load\n        if (!this.noMore && this.$el.scrollTop + this.$el.offsetHeight > this.heights - this.offset) {\n          this.load()\n        }\n        this.updateStartIndex()\n      },\n      _onResize() {\n        const items = this.items\n        items.forEach((item) => {\n          item.loaded = false\n        })\n        this.loadItems(0, items.length)\n      }\n    },\n    components: {\n      CubeLoading\n    }\n  }\n</script>\n\n<style lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .cube-recycle-list\n    position: relative\n    height: 100%\n    overflow-x: hidden\n    overflow-y: auto\n    -webkit-overflow-scrolling: touch\n\n  .cube-recycle-list-main\n    min-height: 100%\n\n  .cube-recycle-list-fake\n    height: 1px\n\n  .cube-recycle-list-invisible\n    top: -1000px\n    visibility: hidden\n\n  .cube-recycle-list-item\n    width: 100%\n    position: absolute\n    box-sizing: border-box\n\n  .cube-recycle-list-transition\n    position: absolute\n    opacity: 0\n    transition-property: opacity\n    transition-duration: 500ms\n\n  .cube-recycle-list-loading\n    overflow: hidden\n\n  .cube-recycle-list-loading-content\n    text-align: center\n  .cube-recycle-list-spinner\n    margin: 10px auto\n    display: flex\n    justify-content: center\n</style>\n"],"sourceRoot":"node_modules/cube-ui/src/components/recycle-list"}]}